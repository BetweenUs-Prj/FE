import { useEffect, useState, useRef, useCallback } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { useGameStore } from '../../hooks/useGameStore';

interface ReactionResult {
  userUid: string;
  deltaMs: number;
  falseStart: boolean;
  rank: number;
}

interface ReactionRound {
  roundId: number;
  sessionId: number;
  status: 'WAITING' | 'PREPARING' | 'RED' | 'FINISHED';
  redAt: number;
  createdAt: number;
  participants: number;
  results: ReactionResult[];
}

interface GameState {
  currentRound: ReactionRound | null;
  playerReady: boolean;
  gameStarted: boolean;
  showResult: boolean;
  myResult: ReactionResult | null;
}

/**
 * REST ê¸°ë°˜ ë°˜ì‘ì†ë„ ê²Œì„ (WebSocket ì™„ì „ ì œê±°)
 */
export default function ReactionGameREST() {
  const { sessionId } = useParams<{ sessionId: string }>();
  const nav = useNavigate();
  const setGameType = useGameStore((s) => s.setGameType);
  const gameType = useGameStore((s) => s.gameType);
  
  const [gameState, setGameState] = useState<GameState>({
    currentRound: null,
    playerReady: false,
    gameStarted: false,
    showResult: false,
    myResult: null
  });
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [countdown, setCountdown] = useState<number | null>(null);
  const [reactionTime, setReactionTime] = useState<number | null>(null);
  const [clicked, setClicked] = useState(false);
  
  const pollingRef = useRef<NodeJS.Timeout | null>(null);
  const countdownRef = useRef<NodeJS.Timeout | null>(null);
  const mountedRef = useRef(true);
  const redStartTime = useRef<number | null>(null);
  
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸
  useEffect(() => {
    console.log('[REACTION] mount sid=' + sessionId);
    try {
      if (setGameType && typeof setGameType === 'function') {
        setGameType('REACTION');
        console.log('[REACTION] Game type set to REACTION');
      } else {
        console.warn('[REACTION] setGameType is not available');
      }
    } catch (error) {
      console.error('[REACTION] Error setting game type:', error);
    }
    mountedRef.current = true;
    
    return () => {
      console.log('[REACTION] unmount sid=' + sessionId);
      mountedRef.current = false;
      if (pollingRef.current) clearInterval(pollingRef.current);
      if (countdownRef.current) clearTimeout(countdownRef.current);
    };
  }, [sessionId, setGameType]);
  
  // í˜„ì¬ ë¼ìš´ë“œ ì¡°íšŒ
  const fetchCurrentRound = useCallback(async (): Promise<boolean> => {
    if (!sessionId || !mountedRef.current) return false;
    
    try {
      const response = await fetch(`/api/mini-games/reaction/sessions/${sessionId}/current-round?ts=${Date.now()}`, {
        headers: {
          'User-Uid': localStorage.getItem('userUid') || 'anonymous',
          'Cache-Control': 'no-cache'
        }
      });
      
      if (response.status === 200) {
        const roundData: ReactionRound = await response.json();
        console.log('[REACTION] Current round:', roundData);
        
        if (!mountedRef.current) return false;
        
        setGameState(prev => ({
          ...prev,
          currentRound: roundData,
          gameStarted: roundData.status !== 'WAITING'
        }));
        
        // ìƒíƒœë³„ ì²˜ë¦¬
        if (roundData.status === 'RED' && !clicked) {
          // ë¹¨ê°„ í™”ë©´ - í´ë¦­ ëŒ€ê¸°
          redStartTime.current = roundData.redAt;
          console.log('[REACTION] Red signal active, redAt:', roundData.redAt);
          
        } else if (roundData.status === 'FINISHED') {
          // ê²Œì„ ì¢…ë£Œ - ê²°ê³¼ í˜ì´ì§€ë¡œ ì´ë™
          console.log('[REACTION] Game finished, navigating to results page');
          
          // ë°±ì—”ë“œì—ì„œ ì„¸ì…˜ ì¢…ë£Œ ì²˜ë¦¬ (í•„ìš”í•œ ê²½ìš°)
          try {
            await fetch(`/api/mini-games/sessions/${sessionId}/finish`, {
              method: 'POST',
              headers: {
                'User-Uid': localStorage.getItem('userUid') || 'anonymous',
                'Content-Type': 'application/json'
              }
            });
          } catch (err) {
            console.log('[REACTION] Session finish call failed (may be expected):', err);
          }
          
          // ê²°ê³¼ í˜ì´ì§€ë¡œ ì´ë™
          nav(`/game/result/${sessionId}`, { 
            replace: true,
            state: { 
              from: 'reaction',
              gameType: 'REACTION'
            }
          });
          
          return true; // í´ë§ ì¤‘ë‹¨
        }
        
        setLoading(false);
        setError(null);
        return false; // í´ë§ ê³„ì†
        
      } else if (response.status === 204) {
        // ë¼ìš´ë“œ ì—†ìŒ - ëŒ€ê¸° ìƒíƒœ
        console.log('[REACTION] No current round, waiting...');
        setGameState(prev => ({ ...prev, currentRound: null }));
        setLoading(false);
        return false;
        
      } else {
        console.log('[REACTION] Fetch error:', response.status);
        setError('ê²Œì„ ìƒíƒœë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        setLoading(false);
        return true;
      }
      
    } catch (err) {
      console.error('[REACTION] Fetch error:', err);
      if (mountedRef.current) {
        setError('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        setLoading(false);
      }
      return true;
    }
  }, [sessionId, clicked]);
  
  // í”Œë ˆì´ì–´ ì¤€ë¹„ ìƒíƒœ ì„¤ì •
  const setPlayerReady = useCallback(async (ready: boolean) => {
    if (!sessionId) return;
    
    try {
      const endpoint = ready ? 'ready' : 'unready';
      const response = await fetch(`/api/mini-games/reaction/sessions/${sessionId}/${endpoint}`, {
        method: 'POST',
        headers: {
          'User-Uid': localStorage.getItem('userUid') || 'anonymous',
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        console.log(`[REACTION] Player ${ready ? 'ready' : 'unready'}`);
        setGameState(prev => ({ ...prev, playerReady: ready }));
      }
      
    } catch (err) {
      console.error('[REACTION] Ready state error:', err);
    }
  }, [sessionId]);
  
  // ë¼ìš´ë“œ ìƒì„±
  const createRound = useCallback(async () => {
    if (!sessionId) return;
    
    try {
      const response = await fetch('/api/mini-games/reaction/rounds', {
        method: 'POST',
        headers: {
          'User-Uid': localStorage.getItem('userUid') || 'anonymous',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ sessionId: parseInt(sessionId) })
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log('[REACTION] Round created:', data);
        
        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (5ì´ˆ)
        setCountdown(5);
        let count = 5;
        
        countdownRef.current = setInterval(() => {
          count--;
          setCountdown(count);
          
          if (count <= 0) {
            if (countdownRef.current) clearInterval(countdownRef.current);
            setCountdown(null);
          }
        }, 1000);
        
      } else {
        setError('ê²Œì„ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
    } catch (err) {
      console.error('[REACTION] Create round error:', err);
      setError('ê²Œì„ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  }, [sessionId]);
  
  // í´ë¦­ ë“±ë¡
  const handleClick = useCallback(async () => {
    if (!gameState.currentRound || clicked || gameState.currentRound.status !== 'RED') return;
    
    setClicked(true);
    const clickTime = Date.now();
    
    // ë°˜ì‘ì‹œê°„ ê³„ì‚° (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ì„ì‹œ ê³„ì‚°)
    if (redStartTime.current) {
      const deltaMs = clickTime - redStartTime.current;
      setReactionTime(deltaMs);
      console.log('[REACTION] Click registered, delta:', deltaMs + 'ms');
    }
    
    try {
      const response = await fetch(`/api/mini-games/reaction/rounds/${gameState.currentRound.roundId}/click`, {
        method: 'POST',
        headers: {
          'User-Uid': localStorage.getItem('userUid') || 'anonymous',
          'Content-Type': 'application/json'
        }
      });
      
      if (response.ok) {
        const result = await response.json();
        console.log('[REACTION] Click result:', result);
        
        // ì„œë²„ì—ì„œ ë°›ì€ ì •í™•í•œ ë°˜ì‘ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸
        setReactionTime(result.deltaMs);
        
      } else {
        console.log('[REACTION] Click registration failed:', response.status);
      }
      
    } catch (err) {
      console.error('[REACTION] Click error:', err);
    }
  }, [gameState.currentRound, clicked]);
  
  // í´ë§ ì‹œì‘
  useEffect(() => {
    if (!sessionId) return;
    
    const startPolling = async () => {
      // í”Œë ˆì´ì–´ ì¤€ë¹„ ìƒíƒœ ì„¤ì •
      await setPlayerReady(true);
      
      // ì²« ì¡°íšŒ
      const finished = await fetchCurrentRound();
      
      if (!finished && mountedRef.current) {
        // 500ms ê°„ê²©ìœ¼ë¡œ í´ë§
        pollingRef.current = setInterval(async () => {
          const finished = await fetchCurrentRound();
          if (finished && pollingRef.current) {
            clearInterval(pollingRef.current);
          }
        }, 500);
      }
    };
    
    startPolling();
    
    return () => {
      if (pollingRef.current) clearInterval(pollingRef.current);
      setPlayerReady(false); // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì¤€ë¹„ í•´ì œ
    };
  }, [sessionId, fetchCurrentRound, setPlayerReady]);
  
  // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ (ìŠ¤í˜ì´ìŠ¤ë°” í´ë¦­)
  useEffect(() => {
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.code === 'Space' && gameState.currentRound?.status === 'RED') {
        e.preventDefault();
        handleClick();
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState.currentRound?.status, handleClick]);
  
  // í™ˆìœ¼ë¡œ ì´ë™
  const handleGoHome = () => nav('/');
  
  // ë¡œë¹„ë¡œ ì´ë™
  const handleBackToLobby = () => nav('/lobby');
  
  // ë‹¤ì‹œ í•˜ê¸°
  const handleRestart = () => {
    setGameState({
      currentRound: null,
      playerReady: false,
      gameStarted: false,
      showResult: false,
      myResult: null
    });
    setClicked(false);
    setReactionTime(null);
    setCountdown(null);
    setLoading(true);
    setError(null);
  };
  
  // ë¡œë”© í™”ë©´
  if (loading) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="bg-gray-800 rounded-lg shadow-lg p-8">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-400 mb-4 mx-auto"></div>
          <p className="text-white text-center">ê²Œì„ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
        </div>
      </div>
    );
  }
  
  // ì—ëŸ¬ í™”ë©´
  if (error) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="bg-gray-800 rounded-lg shadow-lg p-8 text-center">
          <div className="text-red-500 text-5xl mb-4">âš ï¸</div>
          <h2 className="text-xl font-bold text-white mb-2">ì˜¤ë¥˜ ë°œìƒ</h2>
          <p className="text-gray-400 mb-6">{error}</p>
          <button
            onClick={handleGoHome}
            className="px-6 py-2 bg-yellow-500 text-black rounded-lg hover:bg-yellow-600 font-semibold"
          >
            í™ˆìœ¼ë¡œ ì´ë™
          </button>
        </div>
      </div>
    );
  }
  
  // ê²°ê³¼ í˜ì´ì§€ë¡œ ì´ë™ ì¤‘ í™”ë©´ (ì´ ìƒíƒœëŠ” ì‹¤ì œë¡œëŠ” ì ì‹œë§Œ í‘œì‹œë¨)
  if (gameState.showResult) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="bg-gray-800 rounded-lg shadow-lg p-8 text-center">
          <div className="text-6xl mb-4">ğŸ</div>
          <h2 className="text-2xl font-bold text-white mb-4">ê²Œì„ ì¢…ë£Œ!</h2>
          <p className="text-gray-400 mb-2">ê²°ê³¼ í˜ì´ì§€ë¡œ ì´ë™ ì¤‘...</p>
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-yellow-400 mx-auto"></div>
        </div>
      </div>
    );
  }
  
  // ëŒ€ê¸° í™”ë©´
  if (!gameState.currentRound || gameState.currentRound.status === 'WAITING') {
    return (
      <div className="min-h-screen bg-gray-900 p-4 flex items-center justify-center">
        <div className="bg-gray-800 rounded-xl shadow-lg p-12 text-center max-w-2xl">
          <div className="text-6xl mb-6">âš¡</div>
          <h1 className="text-4xl font-bold text-yellow-400 mb-4">ë°˜ì‘ì†ë„ ê²Œì„</h1>
          <p className="text-gray-400 mb-8 text-lg">
            ë¹¨ê°„ ë¶ˆì´ ì¼œì§€ë©´ ìµœëŒ€í•œ ë¹ ë¥´ê²Œ í´ë¦­í•˜ì„¸ìš”!
          </p>
          
          <div className="bg-gray-700 rounded-lg p-6 mb-8">
            <h3 className="text-lg font-bold text-white mb-4">ê²Œì„ ë°©ë²•</h3>
            <div className="text-gray-300 space-y-2 text-left">
              <p>â€¢ ì¤€ë¹„ ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”</p>
              <p>â€¢ ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ëœë¤ ì‹œê°„ì— ë¹¨ê°„ ë¶ˆì´ ì¼œì§‘ë‹ˆë‹¤</p>
              <p>â€¢ ë¹¨ê°„ ë¶ˆì´ ì¼œì§€ë©´ í™”ë©´ì„ í´ë¦­í•˜ê±°ë‚˜ ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆ„ë¥´ì„¸ìš”</p>
              <p>â€¢ ë¹¨ê°„ ë¶ˆì´ ì¼œì§€ê¸° ì „ì— í´ë¦­í•˜ë©´ ë¶€ì •ì¶œë°œì…ë‹ˆë‹¤</p>
            </div>
          </div>
          
          {!gameState.playerReady && (
            <button
              onClick={() => setPlayerReady(true)}
              className="px-8 py-4 bg-yellow-500 text-black rounded-xl hover:bg-yellow-600 font-bold text-xl transition transform hover:scale-105"
            >
              ê²Œì„ ì°¸ê°€
            </button>
          )}
          
          {gameState.playerReady && (
            <div>
              <p className="text-green-400 font-semibold mb-4">ì°¸ê°€ ì™„ë£Œ! ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
              <button
                onClick={createRound}
                className="px-8 py-4 bg-red-500 text-white rounded-xl hover:bg-red-600 font-bold text-xl transition transform hover:scale-105"
              >
                ê²Œì„ ì‹œì‘
              </button>
            </div>
          )}
        </div>
      </div>
    );
  }
  
  // ì¹´ìš´íŠ¸ë‹¤ìš´ í™”ë©´
  if (countdown !== null && countdown > 0) {
    return (
      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div 
            className="text-9xl font-bold text-yellow-400 mb-4 animate-pulse"
            style={{ textShadow: '0 0 50px rgba(255, 193, 7, 0.8)' }}
          >
            {countdown}
          </div>
          <p className="text-2xl text-white">ì¤€ë¹„í•˜ì„¸ìš”...</p>
        </div>
      </div>
    );
  }
  
  // ëŒ€ê¸° ì¤‘ (ë¹¨ê°„ ë¶ˆ ì „)
  if (gameState.currentRound.status === 'PREPARING') {
    return (
      <div 
        className="min-h-screen flex items-center justify-center cursor-pointer"
        style={{ backgroundColor: '#1a1a2e' }}
        onClick={handleClick}
      >
        <div className="text-center">
          <div className="text-6xl mb-6 animate-pulse">â³</div>
          <h2 className="text-3xl font-bold text-white mb-4">ì¤€ë¹„í•˜ì„¸ìš”...</h2>
          <p className="text-gray-400 text-lg">ë¹¨ê°„ ë¶ˆì´ ì¼œì§€ë©´ í´ë¦­í•˜ì„¸ìš”</p>
          <p className="text-gray-500 text-sm mt-4">í™”ë©´ì„ í´ë¦­í•˜ê±°ë‚˜ ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆ„ë¥´ì„¸ìš”</p>
        </div>
      </div>
    );
  }
  
  // ë¹¨ê°„ ë¶ˆ (í´ë¦­ ëŒ€ê¸°)
  if (gameState.currentRound.status === 'RED') {
    return (
      <div 
        className="min-h-screen flex items-center justify-center cursor-pointer"
        style={{ backgroundColor: '#dc2626' }}
        onClick={handleClick}
      >
        <div className="text-center text-white">
          {clicked ? (
            <div>
              <div className="text-8xl mb-4">âœ…</div>
              <h2 className="text-4xl font-bold mb-4">í´ë¦­ ì™„ë£Œ!</h2>
              {reactionTime && (
                <p className="text-2xl font-semibold">
                  ë°˜ì‘ì‹œê°„: {reactionTime}ms
                </p>
              )}
              <p className="text-xl opacity-80 mt-2">ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</p>
            </div>
          ) : (
            <div>
              <div className="text-9xl mb-6 animate-bounce">ğŸ”´</div>
              <h2 className="text-5xl font-bold mb-4">ì§€ê¸ˆ í´ë¦­!</h2>
              <p className="text-2xl opacity-80">í™”ë©´ì„ í´ë¦­í•˜ê±°ë‚˜ ìŠ¤í˜ì´ìŠ¤ë°”ë¥¼ ëˆ„ë¥´ì„¸ìš”</p>
            </div>
          )}
        </div>
      </div>
    );
  }
  
  return null;
}